Отчёт по 2 практической работе
Цель работы
Целью данной практической работы являлось получение и закрепление практических навыков проектирования и разработки Android-приложений с использованием принципов чистой архитектуры (Clean Architecture). Основная задача заключалась в рефакторинге одномодульного приложения в многомодульную структуру с четким разделением ответственностей между слоями: Presentation (app), Domain и Data. В ходе работы необходимо было реализовать ключевые функции современного мобильного приложения: аутентификацию пользователей, работу с локальной базой данных, взаимодействие с внешним сетевым сервисом по API, а также отображение динамических списков данных.
Ход работы
Работа над проектом началась с анализа теоретической части практического задания, в которой описывались недостатки монолитной архитектуры и преимущества разделения логики на независимые слои. Руководствуясь этими принципами, была произведена декомпозиция проекта на три отдельных модуля. Был создан модуль Domain как чистая Java-библиотека, не имеющая зависимостей от Android SDK. Этот модуль стал ядром бизнес-логики, содержащим модели данных, интерфейсы репозиториев (HabitRepository, AuthRepository) и сценарии использования (UseCases). Также был создан модуль data как Android-библиотека, предназначенная для конкретной реализации репозиториев и работы с источниками данных. Модуль app сохранил за собой роль слоя представления (Presentation), отвечающего исключительно за отображение пользовательского интерфейса и взаимодействие с пользователем. Для корректной связи между модулями были настроены файлы сборки build.gradle.kts и главный конфигурационный файл settings.gradle.kts, где были прописаны зависимости app от Domain и data.

<img width="1205" height="457" alt="image" src="https://github.com/user-attachments/assets/7b1daacc-4950-4333-91b2-90562f65eea7" />

Скриншот папки App

<img width="393" height="787" alt="image" src="https://github.com/user-attachments/assets/09fd4b7a-0450-4f94-8698-9fdac80c22a1" />

Скриншот папки data

<img width="457" height="627" alt="image" src="https://github.com/user-attachments/assets/81a961d5-f83b-47fc-9850-bda4237c298e" />

Скриншот папки Domain

<img width="406" height="552" alt="image" src="https://github.com/user-attachments/assets/21b8d77d-f177-477f-a017-94386d371db4" />

Следующим этапом стала реализация системы аутентификации пользователей в соответствии с заданием. Была создана AuthActivity, отвечающая за экраны входа и регистрации. Вся логика взаимодействия с сервисом Firebase Authentication была инкапсулирована в AuthRepositoryImpl, расположенном в data-модуле. Взаимодействие между AuthActivity и репозиторием было организовано строго через UseCases (LoginUserUseCase, RegisterUserUseCase, CheckUserLoggedInUseCase), что позволило полностью отделить UI от деталей реализации аутентификации, как того требует чистая архитектура. Также была реализована проверка текущей сессии пользователя: при повторном запуске приложения авторизованный пользователь сразу попадает на главный экран, минуя страницу входа.
Экран авторизации пользователя

<img width="1919" height="1079" alt="image" src="https://github.com/user-attachments/assets/912ea0d7-d49a-4e1a-86c9-5b55d2f58638" />

В рамках выполнения задания по реализации трех способов обработки данных в репозитории, была проделана следующая работа. Во-первых, для хранения информации о текущем пользователе (его email) были использованы SharedPreferences. Логика сохранения и получения этих данных была реализована в HabitRepositoryImpl и вызывалась через SaveUserNameUseCase и GetUserNameUseCase. Во-вторых, для работы с локальной базой данных была подключена библиотека Room. Были созданы все необходимые компоненты: сущность (HabitEntity), объект доступа к данным (HabitDao) и класс самой базы данных (AppDatabase). В-третьих, для симуляции получения данных из сети был создан класс NetworkApi, который изначально возвращал "замоканный" (статичный) список привычек. HabitRepositoryImpl был запрограммирован таким образом, чтобы при первом запуске (когда база Room пуста) получать данные из NetworkApi, сохранять их в Room и передавать в UI, а при последующих запусках — брать данные напрямую из Room, что значительно ускоряет загрузку.

Для отображения списка привычек на главном экране (MainActivity) вместо статических элементов был использован RecyclerView, являющийся стандартом для отображения динамических списков в Android. Был создан кастомный макет для одного элемента списка (habit_item.xml) и реализован HabitAdapter, который служит мостом между списком данных (List<Habit>) и их визуальным представлением. Данные для адаптера загружались асинхронно через GetHabitsUseCase, а на время загрузки пользователю отображался ProgressBar, что улучшает пользовательский опыт.
Главный экран со списком привычек и приветствием пользователя

<img width="445" height="957" alt="image" src="https://github.com/user-attachments/assets/52aedb1e-ef92-4208-bb12-8efefeb9d766" />

Финальным этапом работы стала реализация взаимодействия с внешним сетевым сервисом для получения данных в формате JSON, что полностью соответствует пункту №2 контрольного задания. Вместо "замоканных" данных была интегрирована работа с погодным API wttr.in. Для выполнения сетевых запросов и парсинга JSON-ответов были подключены библиотеки Retrofit и Gson. Были созданы POJO-классы (WeatherResponse, CurrentCondition и др.), точно соответствующие структуре JSON-ответа от сервера. В HabitRepositoryImpl был добавлен новый метод для получения погоды, который использует Retrofit для выполнения асинхронного сетевого запроса. В MainActivity была добавлена кнопка "Погода", по нажатию на которую через GetWeatherUseCase отправляется запрос, а полученный результат (температура и описание погоды в Москве) отображается пользователю в диалоговом окне AlertDialog. Таким образом, была продемонстрирована работа с реальным внешним API.

Результат запроса к погодному API, отображенный в диалоговом

<img width="463" height="873" alt="image" src="https://github.com/user-attachments/assets/115d6bd3-0cb0-4da2-ba71-932e00e09925" />

Также был разработан макет в Figma на который опирался при выполнении данной практики и дальнейших добавлений в проект. Макет первичный и в дальнейшем будет видоизменятся.

<img width="347" height="753" alt="image" src="https://github.com/user-attachments/assets/92554fe0-1088-4c01-a75d-b8389c498507" />

Вывод:
В ходе выполнения данной практической работы была успешно достигнута поставленная цель. Было разработано многомодульное Android-приложение, архитектура которого строго следует принципам Clean Architecture. Разделение кода на слои Presentation, Domain и Data позволило создать гибкую, масштабируемую и легко тестируемую систему. На практике были освоены и применены ключевые технологии и библиотеки современной Android-разработки, включая Firebase Authentication для аутентификации, Room для работы с локальной базой данных, Retrofit и Gson для взаимодействия с внешним REST API, а также RecyclerView для отображения динамических списков. Реализация всех пунктов контрольного задания подтвердила понимание теоретических основ и умение применять их для решения практических задач. Выстроенная архитектура доказала свою эффективность: например, добавление новой функции получения погоды затронуло в основном data-слой и минимально повлияло на другие части приложения, что демонстрирует низкую связанность и высокую модульность итогового продукта.
